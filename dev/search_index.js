var documenterSearchIndex = {"docs":
[{"location":"manual/overview/#Manual-Overview","page":"Manual Overview","title":"Manual Overview","text":"","category":"section"},{"location":"manual/overview/","page":"Manual Overview","title":"Manual Overview","text":"Pages = [\n    \"manual/datamodel.md\"\n]","category":"page"},{"location":"manual/datamodel/#Data-Model","page":"Data Model","title":"Data Model","text":"","category":"section"},{"location":"manual/datamodel/","page":"Data Model","title":"Data Model","text":"A large amount of Genser's functionality is provided by transforming primary data into an intermediate representation. This intermediate representation is called the \"Genser Data Model.\"","category":"page"},{"location":"manual/datamodel/","page":"Data Model","title":"Data Model","text":"For the most part, you willn not need to think about the data model unless you need to implement custom behavior for your project's types or are implementing a (de)serializer plugin. Genser knows how to automatically derive it's data model from most Julia's built-in types.","category":"page"},{"location":"manual/datamodel/","page":"Data Model","title":"Data Model","text":"note: Note\nGenser is currently in an early stage of development and the data model is likely to be refined as time goes on. A goal of Genser is to provide built-in support for all or most of the data types provided in Julia's base and standard library. If you run into a situation where a data type you need in your project is not yet supported, please file an issue so the type can be implemented.","category":"page"},{"location":"manual/datamodel/#Tags","page":"Data Model","title":"Tags","text":"","category":"section"},{"location":"manual/datamodel/","page":"Data Model","title":"Data Model","text":"All Genser data model types have tag as part of their type. These tags typically match the type of data they contain, but may also be utilized to provide additional context. The tag for a genser value or type can be retrieved with the tag function.","category":"page"},{"location":"manual/datamodel/","page":"Data Model","title":"Data Model","text":"julia> using Genser\n\njulia> Genser.tag(GenserInt64)\nGenser.Tag(:int64)\n\njulia> Genser.tag(GenserURI)\nGenser.Tag(:uri)","category":"page"},{"location":"manual/datamodel/","page":"Data Model","title":"Data Model","text":"Tags can be used for dispatching.","category":"page"},{"location":"manual/datamodel/","page":"Data Model","title":"Data Model","text":"handle_uri(::GenserDataType{Genser.uri}) = \"a URI tagged value\"","category":"page"},{"location":"manual/datamodel/","page":"Data Model","title":"Data Model","text":"It is possible to create custom Genser data model types with custom tags, though care must be taken to ensure the (de)serialization plugins know how to handle the value.","category":"page"},{"location":"manual/datamodel/#Base-type","page":"Data Model","title":"Base type","text":"","category":"section"},{"location":"manual/datamodel/","page":"Data Model","title":"Data Model","text":"The base type for all Genser data model types is GenserDataType{tag}.","category":"page"},{"location":"manual/datamodel/#Nothing-types","page":"Data Model","title":"Nothing types","text":"","category":"section"},{"location":"manual/datamodel/","page":"Data Model","title":"Data Model","text":"GenserUndefined()\nGenserNull()","category":"page"},{"location":"manual/datamodel/","page":"Data Model","title":"Data Model","text":"The default type for nothing values is GenserNull.","category":"page"},{"location":"manual/datamodel/","page":"Data Model","title":"Data Model","text":"julia> gensertypefor(Nothing)\nGenserNull\n\njulia> isequal(nothing, fromgenser(GenserUndefined()))\ntrue","category":"page"},{"location":"manual/datamodel/","page":"Data Model","title":"Data Model","text":"The parent type for nothing values is GenserNothingType{tag}.","category":"page"},{"location":"manual/datamodel/#Basic-types","page":"Data Model","title":"Basic types","text":"","category":"section"},{"location":"manual/datamodel/","page":"Data Model","title":"Data Model","text":"GenserInt8(::Int8)\nGenserUInt8(::UInt8)\nGenserInt16(::Int16)\nGenserUInt16(::UInt16)\nGenserInt32(::Int32)\nGenserUInt32(::UInt32)\nGenserInt64(::Int64)\nGenserUInt64(::UInt64)\nGenserInt128(::Int128)\nGenserUInt128(::UInt128)\nGenserBigInt(::BigInt)\nGenserFloat16(::Float16)\nGenserFloat32(::Float32)\nGenserFloat64(::Float64)\nGenserBool(::Bool)\nGenserChar(::Char)","category":"page"},{"location":"manual/datamodel/","page":"Data Model","title":"Data Model","text":"julia> gensertypefor(UInt16)\nGenserUInt16 (alias for GenserValue{UInt16, Genser.Tag(:uint16)})\n\njulia> gensertypefor(Char)\nGenserChar (alias for GenserValue{Char, Genser.Tag(:char)})","category":"page"},{"location":"manual/datamodel/","page":"Data Model","title":"Data Model","text":"The parent type for basic types is GenserValue{V, tag} where V is the type of the value held by the type.","category":"page"},{"location":"manual/datamodel/","page":"Data Model","title":"Data Model","text":"Additional, the following category types are available for dispatching.","category":"page"},{"location":"manual/datamodel/","page":"Data Model","title":"Data Model","text":"GenserNumberValue{V <: Number}\nGenserIntegerValue{V <: Integer}\nGenserSignedValue{V <: Signed}\nGenserUnsignedValue{V <: Unsigned}\nGenserFloatValue{V <: AbstractFloat}","category":"page"},{"location":"manual/datamodel/#String-types","page":"Data Model","title":"String types","text":"","category":"section"},{"location":"manual/datamodel/","page":"Data Model","title":"Data Model","text":"Strings are handle much like basic types, though the tag is used to provide additional context about the meaning of contained value.","category":"page"},{"location":"manual/datamodel/","page":"Data Model","title":"Data Model","text":"GenserString(::String)\nGenserURI(::String)","category":"page"},{"location":"manual/datamodel/","page":"Data Model","title":"Data Model","text":"julia> gensertypefor(String)\nGenserValue{String, Genser.Tag(:str)}","category":"page"},{"location":"manual/datamodel/","page":"Data Model","title":"Data Model","text":"The category type GenserStringValue{V <: AbstractString} may be used to dispatch on all genser string types.","category":"page"},{"location":"manual/datamodel/","page":"Data Model","title":"Data Model","text":"The default type for all string values is GenserString.","category":"page"},{"location":"manual/datamodel/#Binary-types","page":"Data Model","title":"Binary types","text":"","category":"section"},{"location":"manual/datamodel/","page":"Data Model","title":"Data Model","text":"A binary type is a type that represents Vector{UInt8} data. In general, they work in a similar manner to basic types. However, they contain an additional Encoding parameter that acts as a hint to deserializers about how to convert the value to a string if the format (e.g. JSON) does not support binary values natively.","category":"page"},{"location":"manual/datamodel/","page":"Data Model","title":"Data Model","text":"GenserBinary(::Vector{UInt8})","category":"page"},{"location":"manual/datamodel/","page":"Data Model","title":"Data Model","text":"The base type for binary values is GenserBinaryValue{E <: Encoding}.  This type can be used to dispatch on all binary types regardless of the intended encoding.  The encoding for GenserBinary is Genser.Encoding{:none} which indicates that the value should not be stringified (in JSON it is serialized as an array of bytes).","category":"page"},{"location":"manual/datamodel/","page":"Data Model","title":"Data Model","text":"The default type for all Vector{UInt8} values is GenserBinary.","category":"page"},{"location":"manual/datamodel/","page":"Data Model","title":"Data Model","text":"julia> gensertypefor(Vector{UInt8})\nGenserBinary (alias for GenserBinaryValue{Encoding{:none}})","category":"page"},{"location":"manual/datamodel/#Additional-value-types","page":"Data Model","title":"Additional value types","text":"","category":"section"},{"location":"manual/datamodel/","page":"Data Model","title":"Data Model","text":"GenserUUID(::Base.UUID)\nGenserSymbol(::Symbol)","category":"page"},{"location":"manual/datamodel/","page":"Data Model","title":"Data Model","text":"julia> gensertypefor(Base.UUID)\nGenserUUID (alias for GenserValue{Base.UUID, Genser.Tag(:uuid)})\n\njulia> gensertypefor(Symbol)\nGenserSymbol (alias for GenserValue{Symbol, Genser.Tag(:symbol)})","category":"page"},{"location":"manual/datamodel/#Sequence-types","page":"Data Model","title":"Sequence types","text":"","category":"section"},{"location":"manual/datamodel/","page":"Data Model","title":"Data Model","text":"A sequence represents any array type other than Vector{UInt8}. All Genser sequence types are one-dimensional.","category":"page"},{"location":"manual/datamodel/","page":"Data Model","title":"Data Model","text":"GenserSequence{T <: GenserDataType}","category":"page"},{"location":"manual/datamodel/","page":"Data Model","title":"Data Model","text":"The value of a sequence type is an AbstractVector.","category":"page"},{"location":"manual/datamodel/","page":"Data Model","title":"Data Model","text":"julia> gensertypefor(Vector{String})\nGenserSequence{GenserValue{String, Genser.Tag(:str)}}\n\njulia> gensertypefor(Matrix{UInt8})\nGenserSequence{GenserUInt8}","category":"page"},{"location":"manual/datamodel/#Set-types","page":"Data Model","title":"Set types","text":"","category":"section"},{"location":"manual/datamodel/","page":"Data Model","title":"Data Model","text":"A sequence represents an abstract set of values","category":"page"},{"location":"manual/datamodel/","page":"Data Model","title":"Data Model","text":"GenserSet{T <: GenserDataType}","category":"page"},{"location":"manual/datamodel/","page":"Data Model","title":"Data Model","text":"The value of a set type is an AbstractSet.","category":"page"},{"location":"manual/datamodel/","page":"Data Model","title":"Data Model","text":"A set type is typically serialized in the same format as a sequence type.","category":"page"},{"location":"manual/datamodel/","page":"Data Model","title":"Data Model","text":"julia> gensertypefor(Set{Int64})\nGenserSet{GenserInt64}\n\njulia> gensertypefor(BitSet)\nGenserSet{GenserInt64}","category":"page"},{"location":"manual/datamodel/#Tuple-types","page":"Data Model","title":"Tuple types","text":"","category":"section"},{"location":"manual/datamodel/","page":"Data Model","title":"Data Model","text":"A tuple type is a fixed-length sequence of heterogenous values.","category":"page"},{"location":"manual/datamodel/","page":"Data Model","title":"Data Model","text":"GenserTuple{T <: Tuple} where each type in the tuple is a GenserDataType","category":"page"},{"location":"manual/datamodel/","page":"Data Model","title":"Data Model","text":"A tuple type is typically serialized in the same format as a sequence type.","category":"page"},{"location":"manual/datamodel/","page":"Data Model","title":"Data Model","text":"This is the default type for all Tuple values.","category":"page"},{"location":"manual/datamodel/","page":"Data Model","title":"Data Model","text":"gensertypefor(Tuple{Char,Int32})\nGenserTuple{Tuple{GenserChar, GenserInt32}}","category":"page"},{"location":"manual/datamodel/#Dict-types","page":"Data Model","title":"Dict types","text":"","category":"section"},{"location":"manual/datamodel/","page":"Data Model","title":"Data Model","text":"A dict type is a non-fixed sized container of key-value pairs.","category":"page"},{"location":"manual/datamodel/","page":"Data Model","title":"Data Model","text":"GenserDict{K <: GenserDataType, V <: GenserDataType}","category":"page"},{"location":"manual/datamodel/","page":"Data Model","title":"Data Model","text":"For compatibility with (de)serializers, it is recommended that serialized dictionarys contain keys that can be converted to and from a string.","category":"page"},{"location":"manual/datamodel/","page":"Data Model","title":"Data Model","text":"julia> gensertypefor(Dict{Symbol,String})\nGenserDict{GenserSymbol, GenserValue{String, Genser.Tag(:str)}}\n\njulia> gensertypefor(Base.ImmutableDict{Symbol,String})\nGenserDict{GenserSymbol, GenserValue{String, Genser.Tag(:str)}}","category":"page"},{"location":"manual/datamodel/","page":"Data Model","title":"Data Model","text":"A dict type is the default type for all AbstractDict values.","category":"page"},{"location":"manual/datamodel/#Record-types","page":"Data Model","title":"Record types","text":"","category":"section"},{"location":"manual/datamodel/","page":"Data Model","title":"Data Model","text":"A record type is a fixed length sequence of heterogenous key-value pairs.","category":"page"},{"location":"manual/datamodel/","page":"Data Model","title":"Data Model","text":"GensorRecord{T <: NamedTuple} where each type in the named tuple is a GenserDataType","category":"page"},{"location":"manual/datamodel/","page":"Data Model","title":"Data Model","text":"The keys of a record type are always symbol values. Genser always stores the record as a named tuple internally.","category":"page"},{"location":"manual/datamodel/","page":"Data Model","title":"Data Model","text":"A record type is the default type for all NamedTuple and struct values.","category":"page"},{"location":"manual/datamodel/","page":"Data Model","title":"Data Model","text":"julia> gensertypefor(@NamedTuple{name::String, age::UInt8})\nGenserRecord{NamedTuple{(:name, :age), Tuple{GenserValue{String, Genser.Tag(:str)}, GenserUInt8}}}\n\njulia> struct Person\n           name::String\n           age::UInt8\n       end\n\njulia> gensertypefor(Person)\nGenserRecord{NamedTuple{(:name, :age), Tuple{GenserValue{String, Genser.Tag(:str)}, GenserUInt8}}}","category":"page"},{"location":"manual/datamodel/#Optional-types","page":"Data Model","title":"Optional types","text":"","category":"section"},{"location":"manual/datamodel/","page":"Data Model","title":"Data Model","text":"An optional type is a type that may or may not have a value.","category":"page"},{"location":"manual/datamodel/","page":"Data Model","title":"Data Model","text":"GenserOptional{T <: GenserDataType}","category":"page"},{"location":"manual/datamodel/","page":"Data Model","title":"Data Model","text":"An optional type is the default type for all Union types that include Nothing.","category":"page"},{"location":"manual/datamodel/","page":"Data Model","title":"Data Model","text":"julia> gensertypefor(Union{Symbol,Nothing})\nGenserOptional{GenserSymbol}","category":"page"},{"location":"manual/datamodel/#Variant-types","page":"Data Model","title":"Variant types","text":"","category":"section"},{"location":"manual/datamodel/","page":"Data Model","title":"Data Model","text":"A variant is a value that can contain a value of one or more different types.","category":"page"},{"location":"manual/datamodel/","page":"Data Model","title":"Data Model","text":"GenserVariant{T <: GenserDataType} where T is a Union.","category":"page"},{"location":"manual/datamodel/","page":"Data Model","title":"Data Model","text":"A variant type is the default for all Union types that do not include Nothing.","category":"page"},{"location":"manual/datamodel/","page":"Data Model","title":"Data Model","text":"julia> gensertypefor(Union{Int32,Char})\nGenserVariant{Union{GenserChar, GenserInt32}}","category":"page"},{"location":"manual/datamodel/#Any-type","page":"Data Model","title":"Any type","text":"","category":"section"},{"location":"manual/datamodel/","page":"Data Model","title":"Data Model","text":"The any type is a wrapper type that contains any Genser sub value.","category":"page"},{"location":"manual/datamodel/","page":"Data Model","title":"Data Model","text":"julia> gensertypefor(Any)\nGenserAny","category":"page"},{"location":"lib/public/#Public-API","page":"Public API","title":"Public API","text":"","category":"section"},{"location":"lib/public/","page":"Public API","title":"Public API","text":"Modules = [Genser]\nPrivate = false","category":"page"},{"location":"lib/public/#Genser.GenserDataType","page":"Public API","title":"Genser.GenserDataType","text":"Base Genser data model type\n\n\n\n\n\n","category":"type"},{"location":"lib/public/#Genser.GenserValue","page":"Public API","title":"Genser.GenserValue","text":"A type for most non-collection values\n\n\n\n\n\n","category":"type"},{"location":"","page":"Genser","title":"Genser","text":"CurrentModule = Genser","category":"page"},{"location":"#Genser","page":"Genser","title":"Genser","text":"","category":"section"},{"location":"","page":"Genser","title":"Genser","text":"Documentation for Genser.","category":"page"},{"location":"","page":"Genser","title":"Genser","text":"Generic serialization and deserialization for Julia.","category":"page"},{"location":"#Package-Features","page":"Genser","title":"Package Features","text":"","category":"section"},{"location":"","page":"Genser","title":"Genser","text":"Serialize and deserialize structured data to and from any format via a plugin.\nCustomization of how structs are serialized / deserialized.\nString encoding for binary data.","category":"page"},{"location":"#Examples","page":"Genser","title":"Examples","text":"","category":"section"},{"location":"#Automatic-handling-of-structures","page":"Genser","title":"Automatic handling of structures","text":"","category":"section"},{"location":"","page":"Genser","title":"Genser","text":"using Genser\nimport GenserJSON\nimport GenserCBOR\n\nstruct Person\n    name::String\n    age::Uint8\nend\n\nmary = Person(\"Mary\", 35)\njson = serialize(mary, \"application/json\")\n@assert deserialize(Person, json, \"application/json\") == mary\n\ncbor = serialize(mary, \"application/cbor\")\n@assert deserialize(Person, cbor, \"application/cbor\") == mary","category":"page"},{"location":"#Binary-string-encoding","page":"Genser","title":"Binary string encoding","text":"","category":"section"},{"location":"","page":"Genser","title":"Genser","text":"using Genser\nimport GenserJSON\n\nstruct DataContainer\n    contents::Vector{UInt8}\nend\n\n@fieldencoding DataContainer :contents :base64\n\ndata = DataContainer(UInt8[10,9,8,7])\njson = serialize(data, \"application/json\")\n@assert String(json) == \"{\\\"contents\\\":\\\"CgkIBw==\\\"}\"\n\ndeserialized = deserialize(DataContainer, json, \"application/json\")\n@assert deserialized.contents == data.contents","category":"page"},{"location":"","page":"Genser","title":"Genser","text":"","category":"page"}]
}
